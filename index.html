export default {
  async fetch(request, env) {
    const url = new URL(request.url);

    // CORS
    const corsHeaders = {
      "Access-Control-Allow-Origin": "*", // po ≈æelji suzi na https://artboxmb.github.io
      "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type",
    };
    if (request.method === "OPTIONS") {
      return new Response(null, { headers: corsHeaders });
    }

    // Konstante
    const REPO = "artboxmb/artboxmb";
    const BRANCH = "main";
    const token = env.TOKEN_UPLOAD;
    if (!token) {
      return text("‚ùå TOKEN_UPLOAD nije postavljen u Worker varijablama.", 500);
    }

    // ===== ROUTES =====
    if (request.method === "GET" && url.pathname === "/health") {
      return text("‚úÖ Worker OK", 200);
    }

    if (request.method === "POST" && (url.pathname === "/" || url.pathname === "/upload")) {
      return handleUpload(request, token, REPO, BRANCH, corsHeaders);
    }

    if (request.method === "POST" && url.pathname === "/delete") {
      return handleDelete(request, token, REPO, BRANCH, env, corsHeaders);
    }

    // Default
    return text("üåç Worker aktivan!\nPOST /upload za upload, POST /delete za brisanje.", 200);

    // ===== Helpers (lokalne) =====
    function text(msg, status = 200) {
      return new Response(msg, {
        status,
        headers: { ...corsHeaders, "Content-Type": "text/plain; charset=utf-8" },
      });
    }
  },
};

/** -------------------- UPLOAD -------------------- */
async function handleUpload(request, token, REPO, BRANCH, corsHeaders) {
  try {
    const body = await request.json();
    let { image_name, image_base64, image_desc } = body || {};

    if (!image_name || !image_base64) {
      return new Response("‚ùå Nedostaje ime ili sadr≈æaj slike.", { status: 400, headers: corsHeaders });
    }

    // Sigurnost: zabrani putanje
    if (/[\\/]/.test(image_name) || image_name.includes("..")) {
      return new Response("‚ùå Neispravno ime datoteke.", { status: 400, headers: corsHeaders });
    }

    // PATCH: server-side slugify (sanitize imena + ekstenzija)
    image_name = safeFileName(image_name);

    const uploadUrl = ghUrl(REPO, `uploads/${image_name}`);
    const resImg = await fetch(uploadUrl, {
      method: "PUT",
      headers: ghHeaders(token),
      body: JSON.stringify({
        message: `Add image: ${image_name}`,
        content: image_base64,
        branch: BRANCH,
      }),
    });

    if (!resImg.ok) {
      const err = await resImg.text();
      return new Response(`‚ö†Ô∏è Gre≈°ka pri uploadu slike:\n${err}`, {
        status: resImg.status,
        headers: corsHeaders,
      });
    }

    // Upis opisa u .txt (UTF-8 ‚Üí base64)
    if (image_desc && image_desc.trim() !== "") {
      const txtUrl = ghUrl(REPO, `uploads/${image_name}.txt`);
      const contentB64 = btoa(unescape(encodeURIComponent(image_desc)));
      const resTxt = await fetch(txtUrl, {
        method: "PUT",
        headers: ghHeaders(token),
        body: JSON.stringify({
          message: `Add desc for ${image_name}`,
          content: contentB64,
          branch: BRANCH,
        }),
      });
      if (!resTxt.ok) {
        const err = await resTxt.text();
        return new Response(`‚ö†Ô∏è Gre≈°ka kod spremanja opisa:\n${err}`, {
          status: resTxt.status,
          headers: corsHeaders,
        });
      }
    }

    return new Response("‚úÖ Slika i opis uspje≈°no spremljeni u /uploads/!", { headers: corsHeaders });
  } catch (err) {
    return new Response(`‚ùå Gre≈°ka u radu Workera (upload): ${err.message}`, {
      status: 500,
      headers: corsHeaders,
    });
  }
}

/** -------------------- DELETE -------------------- */
async function handleDelete(request, token, REPO, BRANCH, env, corsHeaders) {
  try {
    const { image_name, password } = await request.json();

    if (!image_name) {
      return json({ ok: false, message: "‚ùå Nedostaje 'image_name'." }, 400, corsHeaders);
    }

    // Sigurnost: zabrani putanje
    if (/[\\/]/.test(image_name) || image_name.includes("..")) {
      return json({ ok: false, message: "‚ùå Neispravno ime datoteke." }, 400, corsHeaders);
    }

    // Lozinka
    const ADMIN_PASSWORD = env.ADMIN_PASSWORD || "ivo11111986";
    if (password !== ADMIN_PASSWORD) {
      return json({ ok: false, message: "‚õî Pogre≈°na lozinka." }, 401, corsHeaders);
    }

    // PATCH: koristi originalno ime (frontend veƒá ≈°alje ‚Äúslug‚Äù), ali korisno je i ovdje osigurati
    const safeName = image_name.trim();

    // 1) Dohvati SHA slike
    const imgPath = `uploads/${safeName}`;
    const imgSha = await getSha(token, REPO, imgPath, BRANCH);
    if (!imgSha) {
      return json({ ok: false, reason: "FILE_NOT_FOUND", message: "‚ö†Ô∏è Slika nije pronaƒëena." }, 404, corsHeaders);
    }

    // 2) Obri≈°i sliku
    const delImgRes = await fetch(ghUrl(REPO, imgPath), {
      method: "DELETE",
      headers: ghHeaders(token),
      body: JSON.stringify({
        message: `Delete image: ${safeName}`,
        sha: imgSha,
        branch: BRANCH,
      }),
    });
    if (!delImgRes.ok) {
      const err = await delImgRes.text();
      return new Response(`‚ö†Ô∏è Brisanje slike nije uspjelo:\n${err}`, { status: delImgRes.status, headers: corsHeaders });
    }

    // 3) Poku≈°aj obrisati i opis (.txt) ako postoji
    const txtPath = `uploads/${safeName}.txt`;
    const txtSha = await getSha(token, REPO, txtPath, BRANCH);
    if (txtSha) {
      await fetch(ghUrl(REPO, txtPath), {
        method: "DELETE",
        headers: ghHeaders(token),
        body: JSON.stringify({
          message: `Delete desc for ${safeName}`,
          sha: txtSha,
          branch: BRANCH,
        }),
      }).catch(() => {});
    }

    return json({ ok: true, message: "‚úÖ Datoteka obrisana." }, 200, corsHeaders);
  } catch (err) {
    return json({ ok: false, message: `‚ùå Gre≈°ka u radu Workera (delete): ${err.message}` }, 500, corsHeaders);
  }
}

/** -------------------- GitHub helpers -------------------- */
// PATCH: v3 Accept + proper encoding
function ghHeaders(token) {
  return {
    Authorization: `token ${token}`,
    "Content-Type": "application/json",
    "User-Agent": "ArtBoxMB-Worker",
    Accept: "application/vnd.github.v3+json",
  };
}

// PATCH: enkodiraj SVAKI segment putanje (radi razmaka i na≈°ih slova)
function ghUrl(repo, path) {
  const safePath = path.split("/").map(seg => encodeURIComponent(seg)).join("/");
  return `https://api.github.com/repos/${repo}/contents/${safePath}`;
}

async function getSha(token, repo, path, branch) {
  const res = await fetch(`${ghUrl(repo, path)}?ref=${encodeURIComponent(branch)}`, {
    headers: ghHeaders(token),
  });
  if (res.status === 404) return null;
  if (!res.ok) {
    const txt = await res.text().catch(() => "");
    throw new Error(`GitHub GET failed: ${res.status} ${txt}`);
  }
  const json = await res.json();
  return json?.sha || null;
}

/** -------------------- Utility -------------------- */
// PATCH: JSON helper s CORS headerima
function json(data, status, corsHeaders) {
  return new Response(JSON.stringify(data), {
    status,
    headers: { ...corsHeaders, "Content-Type": "application/json; charset=utf-8" },
  });
}

// PATCH: sigurno ime fajla (isti algoritam kao na frontendu)
function safeFileName(name) {
  name = String(name || "").trim();
  const dot = name.lastIndexOf(".");
  const rawBase = dot === -1 ? name : name.slice(0, dot);
  const rawExt  = dot === -1 ? ""   : name.slice(dot + 1);

  const base = rawBase
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "") // strip dijakritike
    .replace(/ƒë/g, "d").replace(/ƒê/g, "d")
    .replace(/[^a-zA-Z0-9]+/g, "-")
    .replace(/-+/g, "-").replace(/^-|-$/g, "")
    .toLowerCase();

  const ext = (rawExt || "jpg").toLowerCase();
  const safeExt = /^(jpg|jpeg|png|gif|jfif)$/.test(ext) ? ext : "jpg";

  return `${base || "slika"}.${safeExt}`;
}
